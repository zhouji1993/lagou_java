# Java class

### 1-类：

> <u>具体相同特征或者行为的一种抽象。类是具有相同属性和和行为的一组对象的集合。把相同的或相似的对象归为一类的这个过程就是抽象。</u>
>
> <u>还可以在定义类时为类添加访问修饰符，对类进行访问权限控制；</u>
>
> <u>对类使用的访问修饰符只有public和缺省两种；</u>
>
> <u>被public修饰的类可以从任何地方访问，不受限制；</u>
>
> <u>不加访问修饰符，缺省修饰的类只能从本包中访问，不同包则无法访问到；</u>
>
> <u>但要注意的是：在一个源文件中只能有一个被public修饰的类，并且文件名必须与public的类同名；</u>
>
> <u>如果要定义多个public的类，则必须分别写在不同的源文件中，一个源文件只写一个类是良好的编程习惯。</u>

### 2 - 构造函数：

> <u>当此类型被new的时候会自动执行的一个方法。构造方法没有返回值类型，也不能有返回值。</u>
>
> <u>父类中的构造方法不能被子类继承，即便它是public的;</u>
>
> <u>父类的构造方法负责初始化属于它的成员变量，而子类的构造方法则只需考虑属于自己的成员变量，不必去关注父类的情况。</u>

### 3-重载的三个原则：

 1.方法名相同

 2.参数不同（可以有三方面的不同）

  数量不同、类型不同、 顺序不同

 3.同一作用域

适当地重载构造方法，可以使初始化对象的方式更为灵活。

### 4-this

this引用总是指向调用成员方法的对象本身。


### 5-静态变量

在成员变量前加static关键字，可以将其声明为静态成员变量。静态变量和程序同生命周期；

在没有实例化对象时，可以通过类名访问静态成员变量；

public class Ss { System.out.println(Ss.a);}。也可以通过对象访问静态成员变量，但不论使用的是哪个对象，访

问到的都是同一个变量；

静态成员变量在声明时最好初始化，如果不进行初始化，系统会默认初始化为0。如果类中成员变量被定义为静态，那么不论有多少个对象，静态成员变量只有一份内存拷贝，即所有对象共享该成员变量；

静态成员变量的作用域只在类内部，但其生命周期却贯穿整个程序；静态成员方法只能对类的静态成员变量进行操作；静态成员方法没有this引用。

 

### 6-继承

继承其实就是自动地共享基类中成员属性和成员方法的机制。

继承是能自动传播代码和重用代码的有力工具；

继承能够在某些比较一般的类的基础上建造、建立和扩充新类；

能减少代码和数据的重复冗余度，并通过增强一致性来减少模块间的接口和界面，从而增强了程序的可维护性；

能清晰地体现出类与类之间的层次结构关系。

继承是单方向的，即派生类可以继承和访问基类中的成员，但基类则无法访问派生类中的成员；

在Java中只允许单一继承方式，即一个派生类只能继承于一个基类，而不能象C++中派生类继承于多个基类的多重继承方式。

### 7重写

在类的继承体系结构中，如果子类中出现了与父类中有同原型的方法，那么认为子类中的方法覆盖了父类中的方法（也称为方法重写）；

通过子类的实例调用被覆盖的方法时，将总是调用子类中的方法，而父类中的方法将被隐藏。


### 8-多态

父类new不同的子类然后调用一个同名的方法，由于所有子类都要覆盖此方法，所以方法的效果会有多种形态，此过程就是多态。

引用转型：

使用父类直接new子类。

多态分为静态多态和动态多态

静态多态也称为编译时多态，即在编译时决定调用哪个方法；

静态多态一般是指方法重载；

只要构成了方法重载，就可以认为形成了静态多态的条件；

静态多态与是否发生继承没有必然联系。

动态多态也称为运行时多态，即在运行时才能确定调用哪个方法；

形成动态多态必须具体以下条件：

必须要有继承的情况存在；

在继承中必须要有方法覆盖；

必须由基类的引用指向派生类的实例，并且通过基类的引用调用被覆盖的方法；

由上述条件可以看出，继承是实现动态多态的首要前提。

在有方法覆盖的前提下，并且有引用转型的情况，就将形成动态多态；


### 9-抽象方法、抽象类

如果某个类中包含有抽象方法，那么该类就必须定义成抽象类；

抽象类不可以直接实例化，只可以用来继承；

抽象类的派生子类应该提供对其所有抽象方法的具体实现；

可以这么认为，抽象方法实际上就是由抽象基类强制要求其派生子类必须实现的方法原型；

如果抽象类的派生子类没有实现其中的所有抽象方法，那么该派生子类仍然是抽象类，只能用于继承，而不能实例化；

抽象类中也可以包含有非抽象的方法；

构造方法和静态方法不可以修饰为abstract。

### 10-接口

与抽象类相似，接口同样不可以实例化，只能用于实现；

接口中不能定义非抽象方法，也就是说接口中不能包含有函数实体；

接口中的所有方法都默认为抽象方法，无需在每个方法前加abstract关键字；

接口的实现类应该提供对接口中所有抽象方法的具体实现，否则将成为抽象类；

与抽象类和它的继承类相似，也可以使用接口的引用指向其实现类的对象，从而达到动态多态的效果。

一个类只能继承于一个父类，但可以实现多个接口。


### 11-异常

异常可分为两大类：编译时异常和运行时异常；

Throwable有两个直接子类，它们是：

Error类：Error类的异常通常为内部错误，因此在正常情况下并不期望用户程序捕获它们；

Exception类：绝大部分用户程序应当捕获的异常类的根类；

一些常用的异常类都直接或间接派生自Exception类，因此我们可以认为绝大部分的异常都属于Exception。

throw语句用于手工抛出异常；

执行流程将在throw语句后立即停止，转而寻找与之类型相匹配的catch块；

throw语句的语法是：

 throw (new Exception("·····"));

如果某个函数中的代码有可能引发异常，可以使用try/catch块进行处理，这种处理方式成为“内部处理”；

如果不方便在函数内部进行处理，也可以将异常往函数外部传递，这就要使用到关键字throws；

throws用于将函数内部产生的异常抛给主调函数；

一般语法：

 返回值类型 函数名(参数列表) throws 异常类型



| 异常 | 异常说明 |
| ---- | -------- |
|Exception      | 异常层次结构的根类 |
| RuntimeException | 许多java.lang异常的基类 |
| ArithmeticException | 算术异常，如除数为0 |
| IllegalArgumentException | 方法接收到非法参数 |
| ArrayIndexOutOfBoundsException | 数组下标越界 |
| NullPointerException | 空指针，访问空引用 |
| ClassNotFoundException | 不能加载所需的类 |
| NumberFormatException | 字符串转数字失败 |
| IOExceprion | IO异常的根类 |
| FileNotFOundException | 找不到文件 |
| EOFException | 文件结束 |







### final关键字：

修饰属性：此变量不能被修改。

2-修饰方法：此方法不能被覆盖。

3-修饰类：此类不能被继承。

 

### super关键字

在子类的构造方法中，super关键字可以显式地调用父类的构造方法，用于将参数传递给它；

其一般语法是：

 super(实际参数)；

需要注意的是：该语句必须是子类构造方法的第一条语句。

如果父类和子类中有同名成员，在子类中默认访问是属于自己的那一个成员；

super关键字可以明确地指定要访问父类中的成员；

其一般语法是：

 super.成员名;

前提条件是：父类中的该成员不是private的。

所有重复性功能代码都应该写成一个方法。方便后期修改。

 

### finally

无论try/catch块中发生了什么，finally块都一定会执行；

当异常发生时，程序可能会意外中断，有些被占用的资源就得不到清理。finally块可以确保执行所有的清理工作；

无论是否发生异常，finally块都将执行；

finally块是可选的，可视具体情况决定是否添加；

 finally块必须和try块一起使用，不能单独存在。

